/*
// Вычислите модуль вектора просуммировав квадраты его координат
// и вычислив кввдратный корень полученного значения. Используйте метод `sqrt()` для вычисления
// корня, следующим образом: v.sqrt().


// Вычисление модуля вектора - корень из суммы квадратов координат
fn magnitude(vector: &[f32; 3]) -> f64 {
    // Начальная переменная
    let mut module: f64 = 0.0;
    // Простая итерация по элементам вектора без изменения оных
    for vec_elem in vector {
        // На каждой итерации вычисляется квадрат текущей координаты и складывается
        module += (*vec_elem as f64) * (*vec_elem as f64);
        //println!("module == {module}");
    }
    // У полученного значения вычисляется квадратный корень
    module.sqrt()
}

// Нормализуйте вектор вычислив его модуль и разделив все его координаты на
// этот модудль.


// Функция нормализации вектора
fn normalize(vector: &mut [f32; 3]){
    /*
    let mut k: f32 = 0.0;
    // in cycle
    k = *vec_elem / (module as f32);
    *vec_elem = k;
    */
    // Вычисление текущего модуля вектора
    let module = magnitude(vector);
    // Если модуль равен 0 или NaN, то вектор не изменяется
    if (module.is_nan()) || (module == 0.0f64) {
        return;
    }
    // Цикл по элементам вектора, на этот раз с возможностью их изменять
    for vec_elem in vector.iter_mut() {
        //println!("original vector coordinate == {vec_elem}");
        *vec_elem /= module as f32;
        //println!("new vector coordinate == {k}");
    }
    // Функция ничего не возвращает, так как изменяются значения изменённого в ней вектора
}

// Используйте эту функцию main для проверки своей работы.

fn main() {
    println!("Модуль единичного вектора: {}", magnitude(&[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    let mut v = [0.0, 0.0, 0.0];
    println!("Модуль {v:?}: {}", magnitude(&v));
    normalize(&mut v);
    println!("Модуль {v:?} после нормализации: {}", magnitude(&v));
}
*/
